<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Package design · PlantBiophysics.jl</title><link rel="canonical" href="https://VEZY.github.io/PlantBiophysics.jl/concepts/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PlantBiophysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../get_started/">Getting started</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../photosynthesis/">Photosynthesis</a></li><li><a class="tocitem" href="../gs/">Stomatal conductance</a></li><li><a class="tocitem" href="../energy_balance/">Energy balance</a></li><li><a class="tocitem" href="../light/">Light interception</a></li></ul></li><li><span class="tocitem">Details</span><ul><li class="is-active"><a class="tocitem" href>Package design</a><ul class="internal"><li><a class="tocitem" href="#Objects"><span>Objects</span></a></li><li><a class="tocitem" href="#Processes"><span>Processes</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Concrete-types:-Models"><span>Concrete types: Models</span></a></li></ul></li><li><a class="tocitem" href="../implement_a_model/">Implement a model</a></li></ul></li><li><a class="tocitem" href="../functions/">Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Details</a></li><li class="is-active"><a href>Package design</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Package design</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/VEZY/PlantBiophysics.jl/blob/master/docs/src/concepts.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Concepts-and-design"><a class="docs-heading-anchor" href="#Concepts-and-design">Concepts and design</a><a id="Concepts-and-design-1"></a><a class="docs-heading-anchor-permalink" href="#Concepts-and-design" title="Permalink"></a></h1><p>A particularity of this package is its ability to compose with other code. Users can add their own computations for processes easily, and still benefit freely from all the other ones. This is made possible thanks to Julia&#39;s multiple dispatch. You&#39;ll find more information in this section.</p><h2 id="Objects"><a class="docs-heading-anchor" href="#Objects">Objects</a><a id="Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Objects" title="Permalink"></a></h2><p><strong>Fill this section</strong></p><p>Scene, object, component, list of models, mtg.</p><h2 id="Processes"><a class="docs-heading-anchor" href="#Processes">Processes</a><a id="Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Processes" title="Permalink"></a></h2><p>At the moment, this package is designed to simulate four different processes:</p><ul><li>photosynthesis</li><li>stomatal conductance</li><li>energy balance</li><li>light interception (no models at the moment, but coming soon!)</li></ul><p>These processes can be simulated using different models. Each process is defined by a generic function, and an abstract structure.</p><p>For example <a href="../functions/#PlantBiophysics.AbstractAModel"><code>AbstractAModel</code></a> is the abstract structure used as a supertype of all photosynthesis models, and the <a href="../functions/#PlantBiophysics.photosynthesis"><code>photosynthesis</code></a> function is used to simulate this process.</p><p>Then, particular implementations of models are used to simulate the processes. These implementations are made using a concrete type (or <code>struct</code>) to hold the parameters of the model and their values, and a method for a function.</p><p>For example the Farquhar–von Caemmerer–Berry (FvCB) model (Farquhar et al., 1980; von Caemmerer and Farquhar, 1981) is implemented to simulate the photosynthesis using:</p><ul><li>the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> struct to hold the values of all parameters for the model (use <code>fieldnames(Fvcb)</code> to get them)</li><li>its own method for the <a href="../functions/#PlantBiophysics.assimilation!-Union{Tuple{S}, Tuple{E}, Tuple{I}, Tuple{LeafModels{I,E,var&quot;#s104&quot;,var&quot;#s103&quot;,S} where var&quot;#s103&quot;&lt;:AbstractGsModel where var&quot;#s104&quot;&lt;:FvcbIter,Any}, Tuple{LeafModels{I,E,var&quot;#s51&quot;,var&quot;#s50&quot;,S} where var&quot;#s50&quot;&lt;:AbstractGsModel where var&quot;#s51&quot;&lt;:FvcbIter,Any,Any}} where S where E where I"><code>assimilation!</code></a> function, which is used when a component has the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> type in its photosynthesis field.</li></ul><p>Then, the user calls the <a href="../functions/#PlantBiophysics.photosynthesis"><code>photosynthesis</code></a> function, which call the <a href="../functions/#PlantBiophysics.assimilation!-Union{Tuple{S}, Tuple{E}, Tuple{I}, Tuple{LeafModels{I,E,var&quot;#s104&quot;,var&quot;#s103&quot;,S} where var&quot;#s103&quot;&lt;:AbstractGsModel where var&quot;#s104&quot;&lt;:FvcbIter,Any}, Tuple{LeafModels{I,E,var&quot;#s51&quot;,var&quot;#s50&quot;,S} where var&quot;#s50&quot;&lt;:AbstractGsModel where var&quot;#s51&quot;&lt;:FvcbIter,Any,Any}} where S where E where I"><code>assimilation!</code></a> function itself under the hood. And the right model is found by searching which method of <a href="../functions/#PlantBiophysics.assimilation!-Union{Tuple{S}, Tuple{E}, Tuple{I}, Tuple{LeafModels{I,E,var&quot;#s104&quot;,var&quot;#s103&quot;,S} where var&quot;#s103&quot;&lt;:AbstractGsModel where var&quot;#s104&quot;&lt;:FvcbIter,Any}, Tuple{LeafModels{I,E,var&quot;#s51&quot;,var&quot;#s50&quot;,S} where var&quot;#s50&quot;&lt;:AbstractGsModel where var&quot;#s51&quot;&lt;:FvcbIter,Any,Any}} where S where E where I"><code>assimilation!</code></a> correspond to the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> struct (using Julia&#39;s multiple dispatch).</p><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>The higher abstract type is <a href="../functions/#PlantBiophysics.AbstractModel"><code>AbstractModel</code></a>. All models in this package are subtypes of this structure.</p><p>The second one is <a href="../functions/#PlantBiophysics.AbstractComponentModel"><code>AbstractComponentModel</code></a>, which is a subtype of <a href="../functions/#PlantBiophysics.AbstractModel"><code>AbstractModel</code></a>. It is used to describe a set of models for a given component.</p><p>Then comes the abstract models for each process represented:</p><ul><li><a href="../functions/#PlantBiophysics.AbstractAModel"><code>AbstractAModel</code></a>: assimilation (photosynthesis) abstract struct</li><li><a href="../functions/#PlantBiophysics.AbstractGsModel"><code>AbstractGsModel</code></a>: stomatal conductance abstract struct</li><li><a href="../functions/#PlantBiophysics.AbstractInterceptionModel"><code>AbstractInterceptionModel</code></a>: light interception abstract struct</li><li><a href="../functions/#PlantBiophysics.AbstractEnergyModel"><code>AbstractEnergyModel</code></a>: energy balance abstract struct</li></ul><p>All models for a given process are a subtype of these abstract struct. If you want to implement your own model for a process, you must make it a subtype of them too.</p><p>For example, the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> model is a subtype of <a href="../functions/#PlantBiophysics.AbstractAModel"><code>AbstractAModel</code></a>. You can check this using:</p><pre><code class="language-julia">Fvcb &lt;: AbstractAModel</code></pre><pre class="documenter-example-output">true</pre><h2 id="Concrete-types:-Models"><a class="docs-heading-anchor" href="#Concrete-types:-Models">Concrete types: Models</a><a id="Concrete-types:-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-types:-Models" title="Permalink"></a></h2><h3 id="Model-types"><a class="docs-heading-anchor" href="#Model-types">Model types</a><a id="Model-types-1"></a><a class="docs-heading-anchor-permalink" href="#Model-types" title="Permalink"></a></h3><p>The models used to simulate the processes are implemented using a concrete type (or <code>struct</code>) to hold the parameter values of the models, and to dispatch to the right method for the process functions.</p><p>For example, the Farquhar–von Caemmerer–Berry model for C3 photosynthesis (Farquhar et al., 1980; von Caemmerer and Farquhar, 1981) is implemented using the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> struct. The struct holds the values of all parameters for the model.</p><p>We can use <code>fieldnames</code> to get all the parameter names of this model:</p><pre><code class="language-julia">fieldnames(Fvcb)</code></pre><pre class="documenter-example-output">(:Tᵣ, :VcMaxRef, :JMaxRef, :RdRef, :Eₐᵣ, :O₂, :Eₐⱼ, :Hdⱼ, :Δₛⱼ, :Eₐᵥ, :Hdᵥ, :Δₛᵥ, :α, :θ)</pre><p>That&#39;s a lot of parameters! But no worries, you don&#39;t need to provide them all (see <a href="../photosynthesis/#photosynthesis_page">Photosynthesis</a> for further details).</p><h3 id="Model-implementation"><a class="docs-heading-anchor" href="#Model-implementation">Model implementation</a><a id="Model-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-implementation" title="Permalink"></a></h3><p>Then we have an implementation of the model (<em>i.e.</em> the actual algorithm) for the given process it is meant to simulate. In this case, <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> is made to simulate the <a href="../functions/#PlantBiophysics.photosynthesis"><code>photosynthesis</code></a>, and this process uses a function called <a href="../functions/#PlantBiophysics.assimilation!-Union{Tuple{S}, Tuple{E}, Tuple{I}, Tuple{LeafModels{I,E,var&quot;#s104&quot;,var&quot;#s103&quot;,S} where var&quot;#s103&quot;&lt;:AbstractGsModel where var&quot;#s104&quot;&lt;:FvcbIter,Any}, Tuple{LeafModels{I,E,var&quot;#s51&quot;,var&quot;#s50&quot;,S} where var&quot;#s50&quot;&lt;:AbstractGsModel where var&quot;#s51&quot;&lt;:FvcbIter,Any,Any}} where S where E where I"><code>assimilation!</code></a>, which implements the models for the photosynthesis (<a href="../functions/#PlantBiophysics.photosynthesis"><code>photosynthesis</code></a> is just a nice wrapper for the users).</p><p>So the actual implementation of the Fvcb model is written like this:</p><pre><code class="language-julia">function assimilation!(leaf::LeafModels{I,E,&lt;:Fvcb,&lt;:AbstractGsModel,S}, meteo, constants = Constants()) where {I,E,S}

    [...]

end</code></pre><p>Where <code>[...]</code> represent the lines of code implementing the model.</p><p>The interesting bit is in the function declaration at the top, this is how all the magic happens. The first argument is called <code>leaf</code>, and is an instance of a <a href="../functions/#PlantBiophysics.LeafModels"><code>LeafModels</code></a>. Now if we look at what are the fields of a <a href="../functions/#PlantBiophysics.LeafModels"><code>LeafModels</code></a>:</p><pre><code class="language-julia">fieldnames(LeafModels)</code></pre><pre class="documenter-example-output">(:interception, :energy, :photosynthesis, :stomatal_conductance, :status)</pre><p>we find that it is a structure that holds all models used to simulate the processes of a leaf. So if we want to simulate the photosynthesis with the <code>Fvcb</code> model, our leaf would have an instance of the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> structure in its <code>photosynthesis</code> field, like so:</p><pre><code class="language-julia">leaf = LeafModels(photosynthesis = Fvcb());
leaf.photosynthesis</code></pre><pre class="documenter-example-output">Fvcb{Float64}(25.0, 200.0, 250.0, 0.6, 46390.0, 210.0, 29680.0, 200000.0, 631.88, 58550.0, 200000.0, 629.26, 0.425, 0.9)</pre><p>The <code>photosynthesis</code> field is the third one in a <a href="../functions/#PlantBiophysics.LeafModels"><code>LeafModels</code></a>. So what our function definition says with this:</p><pre><code class="language-julia">leaf::LeafModels{I,E,&lt;:Fvcb,&lt;:AbstractGsModel,S}</code></pre><p>is simply that the leaf argument must be a <a href="../functions/#PlantBiophysics.LeafModels"><code>LeafModels</code></a> with its third field being of type <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a>. This seems perfectly right because what we are talking about here is a function that implements the <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a> model. Note also that the fourth field must be a subtype of <a href="../functions/#PlantBiophysics.AbstractGsModel"><code>AbstractGsModel</code></a>, hence a stomatal conductance model (whatever the model). This is because the <code>Fvcb</code> model couples the assimilation with the stomatal conductance, so we need to simulate the stomatal conductance too for the computation of the assimilation (this is made inside the function).</p><p>Then we also have <code>I</code>, <code>E</code>, and <code>S</code> that are defined as <code>where {I,E,S}</code>. This means we expect something here, but we don&#39;t put any constraint on what it is. This is because we don&#39;t need explicitly a model for these processes (I: light interception, E: energy balance, S: status) to simulate the photosynthesis as soon as we have the values of some required input variables.</p><h3 id="Inputs-and-outputs"><a class="docs-heading-anchor" href="#Inputs-and-outputs">Inputs and outputs</a><a id="Inputs-and-outputs-1"></a><a class="docs-heading-anchor-permalink" href="#Inputs-and-outputs" title="Permalink"></a></h3><p>The status field of the <a href="../functions/#PlantBiophysics.LeafModels"><code>LeafModels</code></a> is used to keep track of the status of the variables related to the leaf. It is used with two purposes:</p><ul><li>input: provide values for variables as input of the model</li><li>output: give the simulated values for output variables</li></ul><p>It is possible to know which variables are required as model input using <a href="../functions/#PlantBiophysics.inputs-Tuple{AbstractModel}"><code>inputs</code></a>, e.g. for <a href="../functions/#PlantBiophysics.Fvcb"><code>Fvcb</code></a>:</p><pre><code class="language-julia">inputs(Fvcb())</code></pre><pre class="documenter-example-output">(:PPFD, :Tₗ, :Cₛ)</pre><p>and the outputs using <a href="../functions/#PlantBiophysics.outputs-Tuple{AbstractModel}"><code>outputs</code></a></p><pre><code class="language-julia">outputs(Fvcb())</code></pre><pre class="documenter-example-output">(:A, :Gₛ, :Cᵢ)</pre><p>It is also possible to get which variables we need to instantiate before calling a process function using <a href="../functions/#PlantBiophysics.to_initialise-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:Union{Missing, AbstractModel}"><code>to_initialise</code></a> on one or several models, or directly on a leaf:</p><pre><code class="language-julia">leaf = LeafModels(photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0));
to_initialise(leaf)</code></pre><pre class="documenter-example-output">4-element Array{Symbol,1}:
 :PPFD
 :Tₗ
 :Cₛ
 :Dₗ</pre><p>If some models simulate the input variables for other models, <a href="../functions/#PlantBiophysics.to_initialise-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:Union{Missing, AbstractModel}"><code>to_initialise</code></a> will return the variables that e can&#39;t simulate only. For example we don&#39;t need to initialize the leaf temperature for the photosynthesis if we provide an energy balance model that will simulate it:</p><pre><code class="language-julia">leaf = LeafModels(energy = Monteith(), photosynthesis = Fvcb(), stomatal_conductance = Medlyn(0.03,12.0));
to_initialise(leaf)</code></pre><pre class="documenter-example-output">4-element Array{Symbol,1}:
 :Rn
 :skyFraction
 :d
 :PPFD</pre><p>Now the inputs have changed, because some are simulated and others are required by the <code>Monteith()</code> model.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../light/">« Light interception</a><a class="docs-footer-nextpage" href="../implement_a_model/">Implement a model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 March 2021 09:40">Thursday 4 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
